# NBCTF-2023-Writeups

# Sudoku Revenge
>This was a challenge in the Newport-Blake 2023 CTF in the *algo* category. My team didn't actually get this challenge in the competition, but we worked on it and evetually got it while the challenge writeups were embargoed.
## The Problem
We are given a square grid of side length, $n\in[100,200]$, with $n$ entries from $1\rightarrow n$. No two initial entries will occupy the same row and column.
For example, the following are potential initial states of the grid given to us if $n$ was much smaller.
```math
\displaylines{
\begin{matrix}
\cdot & \cdot & \cdot & \cdot & \mathbf{3}\\
\cdot & \cdot & \mathbf{1} & \cdot & \cdot\\
\cdot & \mathbf{4} & \cdot & \cdot & \cdot\\
\mathbf{2} & \cdot & \cdot & \cdot & \cdot\\
\cdot & \cdot & \cdot & \mathbf{5} & \cdot
\end{matrix}\\
\\
\begin{matrix}
\cdot & \cdot & \cdot & \mathbf{3} & \cdot & \cdot\\
\mathbf{5} & \cdot & \cdot & \cdot & \cdot & \cdot\\
\cdot & \mathbf{6} & \cdot & \cdot & \cdot & \cdot\\
\cdot & \cdot & \cdot & \cdot & \mathbf{2} & \cdot\\
\cdot & \cdot & \mathbf{1} & \cdot & \cdot & \cdot\\
\cdot & \cdot & \cdot & \cdot & \cdot & \mathbf{4}
\end{matrix}
}
```
The challenge is then to fill in the remaining spots with numbers from $1\rightarrow n$ such that no two of the same numbers share a row or column, much like Sudoku (hence the name). For example, the following are solutions to the grids above.

```math
\begin{align*}
\begin{matrix}
1 & 2 & 5 & 4 & \mathbf{3}\\
4 & 3 & \mathbf{1} & 2 & 5\\
5 & \mathbf{4} & 3 & 1 & 2\\
\mathbf{2} & 5 & 4 & 3 & 1\\
3 & 1 & 2 & \mathbf{5} & 4
\end{matrix}\\
\\
\begin{matrix}
6 & 4 & 5 & \mathbf{3} & 1 & 2\\
\mathbf{5} & 3 & 2 & 4 & 6 & 1\\
1 & \mathbf{6} & 4 & 2 & 3 & 5\\
4 & 1 & 3 & 5 & \mathbf{2} & 6\\
2 & 5 & \mathbf{1} & 6 & 4 & 3\\
3 & 2 & 6 & 1 & 5 & \mathbf{4}
\end{matrix}
\end{align*}
```
## Latin Squares and Symmetry
My teammate, who did the vast majority of the work on this challenge, discovered that this is called a *Latin Square* problem, so the above solutions were generated using dcode.fr's Latin Square solver. The problem is then finding a way to efficiently solve Latin Squares of much larger size.

Taking inspiration from row operations in Gaussian Eliminations. I eventually noticed that there is a symmetry in the Latin Squares; **any two rows or columns of a valid solution can be swapped, and the grid remains valid**.
```math
\begin{align*}
\begin{matrix}
1 & 2 & 3\\
3 & 1 & 2\\
2 & 3 & 1\\
 & \uparrow & \uparrow
\end{matrix}\\
\text{Swap}\\
\\
\begin{matrix}
1 & 3 & 2\\
3 & 2 & 1\\
2 & 1 & 3\\
 & \uparrow & \uparrow
\end{matrix}\\
\text{Still valid}
\end{align*}
```
Note also that trivial solutions can be generated by simply shifting the sequence from $1\dots n$ to the right each row.
```math
\begin{align*}
\begin{matrix}
1 & 2 & 3 & 4 & 5\\
5 & 1 & 2 & 3 & 4\\
4 & 5 & 1 & 2 & 3\\
3 & 4 & 5 & 1 & 2\\
2 & 3 & 4 & 5 & 1
\end{matrix}
\end{align*}
```
Therefore, the problem has been reduced to finding a set of permutations to permute a trivial solution such that the initial entries match. This problem is still difficult however.

## Solving Odd Cases
My teammate then noticed that in a another class of trivial solutions (working only for matrices of odd size), generated by filling the main diagonal with $1\dots n$ and making each column go down in descending order, the fact that $1\dots n$ is present on the diagonal can be used to our advantage. This diagonal sequence with $1\dots n$ is referred to as a *diagonal transverse* (in this case, ascending in order as this made things easier for us).
```math
\begin{align*}
\begin{matrix}
\mathbf{1} & 5 & 4 & 3 & 2\\
3 & \mathbf{2} & 1 & 5 & 4\\
5 & 4 & \mathbf{3} & 2 & 1\\
2 & 1 & 5 & \mathbf{4} & 3\\
4 & 3 & 2 & 1 & \mathbf{5}
\end{matrix}
\end{align*}
```
Keeping this in mind, consider a set of permutations bringing the initial configuration to a similar diagonal sequence from $1\dots n$. This can be done simply by finding the first number, swapping its to its correct row, then to its correct column, and repeating this for all the numbers.
```math
\begin{align*}
\begin{matrix}
\cdot & \cdot & \cdot & \cdot & \mathbf{3} & \\
\cdot & \cdot & \underline{1} & \cdot & \cdot & \\
\cdot & \mathbf{4} & \cdot & \cdot & \cdot & \\
\mathbf{2} & \cdot & \cdot & \cdot & \cdot & \\
\cdot & \cdot & \cdot & \mathbf{5} & \cdot & \\
\uparrow & & \uparrow & &
\end{matrix}
&\Rightarrow
\begin{matrix}
\cdot & \cdot & \cdot & \cdot & \mathbf{3} & \leftarrow\\
\underline{1} & \cdot & \cdot & \cdot & \cdot & \leftarrow\\
\cdot & \mathbf{4} & \cdot & \cdot & \cdot\\
\cdot & \cdot & \mathbf{2} & \cdot & \cdot\\
\cdot & \cdot & \cdot & \mathbf{5} & \cdot\\
 & 
\end{matrix}\\
\\
\Rightarrow
\begin{matrix}
\mathbf{1} & \cdot & \cdot & \cdot & \cdot & \\
\cdot & \cdot & \cdot & \cdot & \mathbf{3} & \\
\cdot & \mathbf{4} & \cdot & \cdot & \cdot & \\
\cdot & \cdot & \underline{2} & \cdot & \cdot & \\
\cdot & \cdot & \cdot & \mathbf{5} & \cdot & \\
&\uparrow&\uparrow&&
\end{matrix}
&\Rightarrow
\begin{matrix}
\mathbf{1} & \cdot & \cdot & \cdot & \cdot &\\
\cdot & \cdot & \cdot & \cdot & \mathbf{3} & \leftarrow\\
\cdot & \cdot & \mathbf{4} & \cdot & \cdot\\
\cdot & \underline{2} & \cdot & \cdot & \cdot & \leftarrow\\
\cdot & \cdot & \cdot & \mathbf{5} & \cdot\\
 & 
\end{matrix}\\
\\
\Rightarrow
\begin{matrix}
\mathbf{1} & \cdot & \cdot & \cdot & \cdot &\\
\cdot & \mathbf{2} & \cdot & \cdot & \cdot &\\
\cdot & \cdot & \mathbf{4} & \cdot & \cdot\\
\cdot & \cdot & \cdot & \cdot & \underline{3} &\\
\cdot & \cdot & \cdot & \mathbf{5} & \cdot\\
 & & \uparrow& & \uparrow
\end{matrix}
&\Rightarrow\cdots\\
\\
\Rightarrow
\begin{matrix}
1 & \cdot & \cdot & \cdot & \cdot\\
\cdot & 2 & \cdot & \cdot & \cdot\\
\cdot & \cdot & 3 & \cdot & \cdot\\
\cdot & \cdot & \cdot & 4 & \cdot\\
\cdot & \cdot & \cdot & \cdot & 5\\
 & 
\end{matrix}
&\ 
\end{align*}
```
This set of permutation could be reversed to reach the initial configuration from this diagonal transverse. What my teammate realised was that we can find this set of moves, generate a trivial solution with a diagonal transverse, then **reverse this set of moves and apply it to the solution to generate a solution fitting the initial conditions**. This works well for odd cases, however it is less obvious how to generate a matrix of even size with a diagonal transverse.

## Solving Even Cases
The way to do this that I came up with was to begin with a trivial odd solution, and use the following steps to add a row and column while remaining a valid solution with a diagonal transverse.

Begin with an odd solution.
```math
\begin{align*}
\begin{matrix}
\mathbf{1} & 5 & 4 & 3 & 2\\
3 & \mathbf{2} & 1 & 5 & 4\\
5 & 4 & \mathbf{3} & 2 & 1\\
2 & 1 & 5 & \mathbf{4} & 3\\
4 & 3 & 2 & 1 & \mathbf{5}
\end{matrix}
\end{align*}
```
Now, add a row and column, increasing $n$ by one, and set the new corner element to $n$ so that the diagonal is transverse.
```math
\begin{align*}
\begin{matrix}
1 & 5 & 4 & 3 & 2 & \cdot\\
3 & 2 & 1 & 5 & 4 & \cdot\\
5 & 4 & 3 & 2 & 1 & \cdot\\
2 & 1 & 5 & 4 & 3 & \cdot\\
4 & 3 & 2 & 1 & 5 & \cdot\\
\cdot & \cdot & \cdot & \cdot & \cdot & \underline{6}
\end{matrix}
\end{align*}
```
Now, select all elements in the diagonal above the main diagonal, wrapping around to the other side as though the matrix was still the smaller version.
```math
\begin{align*}
\begin{matrix}
1 & \underline{\mathbf{5}} & 4 & 3 & 2 & \cdot\\
3 & 2 & \underline{\mathbf{1}} & 5 & 4 & \cdot\\
5 & 4 & 3 & \underline{\mathbf{2}} & 1 & \cdot\\
2 & 1 & 5 & 4 & \underline{\mathbf{3}} & \cdot\\
\underline{\mathbf{4}} & 3 & 2 & 1 & 5 & \cdot\\
\cdot & \cdot & \cdot & \cdot & \cdot & 6
\end{matrix}
\end{align*}
```
Thanks to the properties of this class of trivial odd solutions, this will also be a transverse. Now set each empty element to the selected number is shares a row or column with.
```math
\begin{align*}
\begin{matrix}
1 & \underline{\mathbf{5}} & 4 & 3 & 2 & \underline{\mathbf{5}}\\
3 & 2 & \underline{\mathbf{1}} & 5 & 4 & \underline{\mathbf{1}}\\
5 & 4 & 3 & \underline{\mathbf{2}} & 1 & \underline{\mathbf{2}}\\
2 & 1 & 5 & 4 & \underline{\mathbf{3}} & \underline{\mathbf{3}}\\
\underline{\mathbf{4}} & 3 & 2 & 1 & 5 & \underline{\mathbf{4}}\\
\underline{\mathbf{4}} & \underline{\mathbf{5}} & \underline{\mathbf{1}} & \underline{\mathbf{2}} & \underline{\mathbf{3}} & 6
\end{matrix}
\end{align*}
```
The matrix is now invalid as it contains duplicates in the original subsection of the matrix. Replace these duplicates with the new $n$, in this case 6.
```math
\begin{align*}
\begin{matrix}
1 & \underline{\mathbf{6}} & 4 & 3 & 2 & 5\\
3 & 2 & \underline{\mathbf{6}} & 5 & 4 & 1\\
5 & 4 & 3 & \underline{\mathbf{6}} & 1 & 2\\
2 & 1 & 5 & 4 & \underline{\mathbf{6}} & 3\\
\underline{\mathbf{6}} & 3 & 2 & 1 & 5 & 4\\
4 & 5 & 1 & 2 & 3 & 6
\end{matrix}
\end{align*}
```
We now have a solution matrix of even size with a diagonal transverse. For even sized squares given, we can once again find a set of moves to bring the initial configuration to a diagonal transverse, find a trivial solution with a diagonal transverse, and then reverse the set of moves to bring the solution to match the initial conditions given to us.

## Final Solution
My teammate implemented this in python to run on the challenge server, which gave us the flag.
```python
import pexpect
from pexpect import popen_spawn
import numpy as np

child = popen_spawn.PopenSpawn("ncat chal.nbctf.com 30274", encoding='utf-8')

def getNext():
    child.expect("\n")
    return child.before

def diagSq(n):
    if n%2:
        return np.array([np.roll(np.arange(n,0,-1), 1+2*i) for i in range(n)])
    else:
        sq = np.pad(diagSq(n-1), ((0,1),(0,1)))
        sq[-1,-1] = n
        for i in range(n-1):
            j = (n-2+i)%(n-1)
            sq[n-1][i], sq[j][n-1], sq[j][i] = sq[j][i], sq[j][i], n
        return sq

t = int(getNext())
print(t,"Cases to solve\n")
for case in range(t):
    n = int(getNext())
    print("n =",n)
    a = list(map(int, getNext().split()))

    arr = np.zeros((n, n)).astype(int)
    for i in range(n):
        arr[i][a[i] - 1] = i + 1

    #Permute initial into diagonalised
    moves = []
    for i in range(n):
        w = np.where(arr == i+1)
        arr[:,[i, int(w[1])]] = arr[:,[int(w[1]), i]]
        moves.append((i, int(w[1])))

    #Find diagonalisation
    sol = diagSq(n)
    
    #Permute diagonalised into initial format
    for m in reversed(moves):
        sol[:,[m[0], m[1]]] = sol[:,[m[1],m[0]]]
        
    print(sol)
    print(f"Case {case+1} Complete")
    for y in range(n):
        child.sendline(" ".join(sol[y].astype(str)))
print(getNext())
```

```
nbctf{th1s_1s_whY_y0U_t3s7_tH3_ch3Ck3r_f1r57}
```
